// Rod Cutting Problem | (DP - 24)

// Problem Statement
// We are given a rod of size N. It can be cut into pieces, and each piece of length i has a price given by the price[i-1] array.
// Our task is to find the maximum revenue that can be generated by cutting the rod (possibly into multiple pieces) and selling them.
// This means we need to determine how to split the rod such that the sum of prices of chosen piece lengths is maximized.

// Intuition
// This is very similar to the Unbounded Knapsack problem because:
// For each rod length (like an item with weight), we have a price (like item value).
// We can choose the same rod length multiple times (just like in unbounded knapsack).
// Our goal is to maximize the profit (price).
// Thus, Rod Cutting is just a variation of unbounded knapsack where capacity = N and rod lengths (1, 2, â€¦ N) act like weights.

// ðŸ“Œ Memoization Approach
// Letâ€™s define:
// f(ind, N) = Maximum profit by cutting a rod of length N using only rod lengths up to (ind+1).
// Choice 1: Donâ€™t take current rod length (ind+1)
// notTake = f(ind-1, N)
// Choice 2: Take current rod length (ind+1)
// If (ind+1) <= N, then
// take = price[ind] + f(ind, N - (ind+1))
// Base Case:
// If ind == 0, we can only cut rods of size 1.
// So the maximum price = N * price.
#include <bits/stdc++.h>
using namespace std;

int f(int ind, int N, vector<int> &price, vector<vector<int>> &dp) {
    if (ind == 0) return N * price[0];
    if (dp[ind][N] != -1) return dp[ind][N];

    int notTake = f(ind - 1, N, price, dp);
    int take = INT_MIN;

    int rodLength = ind + 1;
    if (rodLength <= N) {
        take = price[ind] + f(ind, N - rodLength, price, dp);
    }

    return dp[ind][N] = max(take, notTake);
}

int cutRod(vector<int> &price, int n) {
    vector<vector<int>> dp(n, vector<int>(n + 1, -1));
    return f(n - 1, n, price, dp);
}

int main() {
    vector<int> price = {2, 5, 7, 8, 10};
    cout << cutRod(price, price.size()) << endl;
    return 0;
}
// Output for {2,5,7,8,10} with n=5 â†’ 12
// Complexity Analysis (Memoization)
// Time Complexity: O(N * N) â†’ For each state (ind, N) we compute once.
// Space Complexity: O(N * N) + O(N) â†’ DP table + recursion stack.

// ðŸ“Œ Tabulation Approach
// Now we build a dp table iteratively.
// Steps:
// Define dp[ind][N] = max profit using first ind+1 lengths and total rod length = N.
// Base Case: For ind=0, we can only use rod length 1.
// â‡’ dp[N] = N * price.
// Transition relation same as memoization:
// dp[ind][N] = max(
//                 dp[ind-1][N],                   // not take
//                 price[ind] + dp[ind][N - (ind+1)]  // take
//              )
int cutRod(vector<int> &price, int n) {
    vector<vector<int>> dp(n, vector<int>(n + 1, 0));

    // Base case: only rod length = 1 can be used
    for (int N = 0; N <= n; N++) {
        dp[0][N] = N * price[0];
    }

    for (int ind = 1; ind < n; ind++) {
        for (int N = 0; N <= n; N++) {
            int notTake = dp[ind - 1][N];
            int take = INT_MIN;
            int rodLength = ind + 1;

            if (rodLength <= N) {
                take = price[ind] + dp[ind][N - rodLength];
            }

            dp[ind][N] = max(take, notTake);
        }
    }

    return dp[n - 1][n];
}
// Output: 12
// Complexity Analysis (Tabulation)
// Time Complexity: O(N * N)
// Space Complexity: O(N * N)

// ðŸ“Œ Space Optimization Approach
// We notice:
// dp[ind][N] = max(dp[ind-1][N] , price[ind] + dp[ind][N - (ind+1)])
// ðŸ‘‰ Only dp[ind-1][...] (previous row) and dp[ind][...] (current row) are required.
// So we can optimize from O(N*N) space â†’ O(N).
#include <bits/stdc++.h>
using namespace std;
int cutRod(vector<int> &price, int n) {
	// Write your code here.
	vector<int> prev(n + 1, 0), curr(n + 1, 0);

	for(int N = 0; N <= n; N++){
		prev[N] = N * price[0];
	}

	for(int ind = 1; ind < n; ind++){
		for(int N = 0; N <= n; N++){
			int notTake = 0 + prev[N];
			int take = INT_MIN;
			int rodLength = ind + 1;
			if(rodLength <= N){
				take = price[ind] + curr[N - rodLength];
			}
			curr[N] = max(take, notTake);
		}
		prev = curr;
	}
	return prev[n];
}

// Output: 12
// Complexity Analysis (Space Optimized)
// Time Complexity: O(N * N)
// Space Complexity: O(N)