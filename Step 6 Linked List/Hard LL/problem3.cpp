// Problem 3:
// Flattening a Linked List
// Problem Statement: Given a linked list containing ‘N’ head nodes where every node in the linked list contains two pointers:
// ‘Next’ points to the next node in the list
// ‘Child’ pointer to a linked list where the current node is the head
// Each of these child linked lists is in sorted order and connected by a 'child' pointer. Your task is to flatten this linked list such that all nodes appear in a single layer or level in a 'sorted order'.

#include <bits/stdc++.h>
using namespace std;

class Node
{
public:
    int data;
    Node *next;
    Node *bottom;

public:
    Node(int data1, Node *next1, Node *bottom1)
    {
        data = data1;
        next = next1;
        bottom = bottom1;
    }

public:
    Node(int data1)
    {
        data = data1;
        next = NULL;
        bottom = NULL;
    }
};

Node *convertArr2LL(vector<int> &arr)
{
    Node *head = new Node(arr[0]);
    Node *mover = head;
    for (int i = 1; i < arr.size(); i++)
    {
        Node *temp = new Node(arr[i]);
        mover->next = temp;
        mover = temp; // mover = mover -> next
    }
    return head;
}

void print(Node *head)
{
    while (head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

// Brute Force:
// To transform the given linked list into a single level sorted list ensuring that the nodes are arranged in an ascending order, we initialise an array to temporarily hold the extracted nodes during the traversal.
// We iterate over the array by first going over the top-level next pointers of the linked list then accessing each node within its child pointers adding all to the array. Then the array is sorted to arrange all values sequentially and a new linked list from that array is created and returned.
// Time Complexity: O(N*M) + O(N*M log(N*M)) + O(N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointer.
// O(N*M) as we traverse through all the elements, iterating through ‘N’ nodes along the next pointer and ‘M’ nodes along the child pointer.
// O(N*M log(N*M)) as we sort the array containing N*M (total) elements.
// O(N*M) as we reconstruct the linked list from the sorted array by iterating over the N*M elements of the array.
// Space Complexity : O(N*M) + O(N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointer.
// O(N*M) for storing all the elements in an additional array for sorting.
// O(N*M) to reconstruct the linked list from the array after sorting
// Function to convert a vector to a linked list
Node* convertArrToLinkedList(vector<int>& arr){
    // Create a dummy node to serve as
    // the head of the linked list
    Node* dummyNode = new Node(-1);
    Node* temp = dummyNode;

    // Iterate through the vector and
    // create nodes with vector elements
    for(int i = 0; i < arr.size(); i++){
        // Create a new node
        // with the vector element
        temp->bottom = new Node(arr[i]); 
        // Move the temporary pointer
        // to the newly created node
        temp = temp->bottom; 
    }
    // Return the linked list starting
    // from the next of the dummy node
    return dummyNode->bottom; 
}

// Function to flatten a
// linked list with child pointers
Node* flattenLinkedList(Node* head) {
    vector<int> arr;

    // Traverse through the linked list
    while (head != nullptr) {
        // Traverse through the child
        // nodes of each head node
        Node* t2 = head;
        while (t2 != nullptr) {
            // Store each node's data in the array
            arr.push_back(t2->data);
            // Move to the next child node
            t2 = t2->bottom;
        }
        // Move to the next head node
        head = head->next;
    }

    // Sort the array containing
    // node values in ascending order
    sort(arr.begin(), arr.end());

    // Convert the sorted array
    // back to a linked list
    return convertArrToLinkedList(arr);
}

// Optimal Approach:
// The time and space complexity of the previous approach can be optimised as we have not yet leveraged the given property that the child linked lists are sorted. We can eliminate the additional space and time complexity generated by sorting by using these sorted vertical linked lists.
// Instead of collecting all node values into an array and then sorting them, we can merge these pre-sorted lists directly during the traversal, eliminating the need for additional sorting steps. This merge operation can be performed efficiently in place without allocating extra space for the combined linked list.
// Read more about Merging Sorted Linked Lists. The base case ensures the termination of the recursion when there's either no list or only a single node remaining. The recursive function then handles the merging of the remaining lists after recursive flattening, creating a sorted flattened linked list.
// Time Complexity: O( N*(2M) ) ~ O(2 N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointers.
// The merge operation in each recursive call takes time complexity proportional to the length of the linked lists being merged as they have to iterate over the entire lists. Since the vertical depth of the linked lists is assume to be M, the time complexity for a single merge operation is proportional to O(2*M).
// This operation operation is performed N number of times (to each and every node along the next pointer list) hence the resultant time complexity becomes: O(N* 2M).
// Space Complexity : O(1) as this algorithm uses no external space or additional data structures to store values. But a recursive stack uses O(N) space to build the recursive calls for each node along the next pointer list.
Node *merge(Node *list1, Node *list2)
{
    Node *dummyNode = new Node(-1);
    Node *result = dummyNode;
    while (list1 != NULL && list2 != NULL)
    {
        if (list1->data < list2->data)
        {
            result->bottom = list1;
            result = list1;
            list1 = list1->bottom;
        }
        else    
        {
            result->bottom = list2;
            result = list2;
            list2 = list2->bottom;
        }
        result->next = NULL;
    }
    if (list1)
        result->bottom = list1;
    else
        result->bottom = list2;
    if (dummyNode->bottom)
        dummyNode->bottom->next = NULL;
    return dummyNode->bottom;
}

// Function which returns the  root of the flattened linked list.
Node *flatten(Node *root)
{
    // Your code here
    if (root == NULL || root->next == NULL)
        return root;
    Node *mergedHead = flatten(root->next);
    root = merge(root, mergedHead);
    return root;
}